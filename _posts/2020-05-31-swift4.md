---
title:  "Swift 자료형(Data Type)"
excerpt: "Swift 자료형(Data Type)을 배워봅시다."

categories:
  - Swift
tags:
  - Swift
last_modified_at: 2020-05-31T020:22:00
---

### 자료형(Data Type)

---

자료형은 Swift에서 다루어지는 정수, 실수, 문자열 등의 데이터의 종류들을 나타냅니다.

다음은 정수 타입의 변수를 선언한 예제입니다.

```swift
var number: Int = 10 + 1 // number라는 이름의 변수를 선언 하고 11이라는 초기값을 저장
```

위 수식에서 *var*은 변수를 선언하겠다는 의미, 'number'는 변수의 이름, *Int*는 이 변수가 정수형 변수라는 것을 나타내는 것, 마지막으로 '= 10 + 1'은 'number'라는 정수형 변수를 11로 초기화 하겠다는 것을 뜻합니다.

즉, 위 'number'라는 이름을 가진 변수의 자료형은 *Int*형입니다.

다음 예제를 볼까요?

```swift
var number: Int = 10 + 1 // number라는 이름의 변수를 선언 하고 11이라는 초기값을 저장
number = 3.14 // Error 발생!! 정수형 변수에 3.14라는 실수 데이터를 저장하려고 함
```

위 예제는 number를 *Int* 타입으로 선언하면서 10으로 초기화 한 후 강제로 정수가 아닌 3.14라는 실수를 저장하려고 시도하고 있습니다.

결과를 볼까요?
![data type 에러](/assets/posts/type_error.png)

실행하기도 전에 "Cannot assign value of type 'Double' to type 'Int'"라는 에러가 발생합니다.

따라서 모든 변수는 처음에 선언할 때 지정된 자료형의 데이터 외에 다른 데이터를 저장하려고 하면 에러가 발생한다는 것을 알 수 있습니다.

### 자료형(Data Type)의 종류

Swift 자료형은 크게 정수, 부호없는 정수, 부동소수점, 문자열, 문자, 불리언(논리형) 등이 있습니다.

#### 정수형(Integer)

정수형 자료형은 ..., -2, -1, 0, 1, 2, ... 등의 정수를 저장하기 위한 자료형입니다.

정수형의 키워드는 *Int*를 사용합니다.

위의 예제를 복습삼아 다시 봅시다.

```swift
var number: Int = 10 + 1 // number라는 이름의 변수를 선언 하고 11이라는 초기값을 저장
number = 4 // number에 4를 정수를 저장
number = -10 // number에 -10을 저장
number = 1000 * 1000 // number에 1000에 1000을 곱한 1000000을 저장
number = 10 / 3 // number에 10을 3으로 나눈 몫인 3을 저장
```

위 number라는 변수는 *Int* 키워드를 이용하여 선언된 정수형 변수에 다양한 정수를 대입하는 다양한 예제입니다.

정수형 자료형이 어떤 것인지 잘 이해 되시죠? 정수형 자료형은 Swift 언어로 개발할 때 제일 많이 쓰이는 자료형입니다.

꼭 기억해 주세요.

Swift에서 정수형은 *Int* 외에 *Int8*, *Int16*, *Int32*, *In64*가 더 있습니다.

*Int8*, *Int16*, *Int32*, *Int64* 자료형에도 동일하게 정수를 저장할 수 있습니다.

그럼 *Int* 외에 저 자료형들은 *Int*와 무슨 차이점이 있을까요?

그것은 바로 저장할 수 있는 수의 범위입니다.

각 자료형 별로 저장할 수 있는 정수의 범위가 다 다르며 그 범위는 다음과 같습니다.

* *Int8*: -128 ~ 127
* *Int16*: -32768 ~ 32767
* *Int32*: -2147483648 ~ 2147483647
* *Int64*: -9223372036854775808 ~ 9223372036854775807
* *Int*: -9223372036854775808 ~ 9223372036854775807

이 정수의 범위를 굳이 외울 필요는 없습니다. 그냥 각 자료형 별로 저장할 수 있는 수의 범위가 있구나 정도로 이해만 하고 넘어가시면 됩니다.

위의 보기와 같이 Int8에 저장할 수 있는 숫자는 -128 ~ 127까지입니다. 즉, Int8에는 저 범위를 벗어나는 200이라는 숫자를 저장할 수 없습니다.

다음 예제를 보시죠.

```swift
var smallNumber: Int8 = 200 // 에러 발생!!!
```

위 예제는 *Int8* 타입의 정수형 변수를 선언하고 200으로 초기화한 예제입니다. 위 수식이 정상적으로 동작할까요?

위에서 *Int8* 자료형의 범위는 -128~127이라고 했죠? 위, 수식은 Int8 자료형의 변수에 Int8이 저장할 수 있는 범위를 벗어나는 수를 저장하려고 했습니다.

따라서, 위 수식은 잘못된 수식입니다.

실제 Xcode에서 확인해 보시죠.
![overflow 에러](/assets/posts/overflow.png)

*Int8* 타입으로 선언한 변수에 200의 값을 저장하려고 했더니 에러가 나죠?

그렇듯, 각 정수형 타입에는 저장할 수 있는 범위가 있고 그 범위를 넘어가면 에러가 발생합니다.

*Int8* 자료형과는 달리 *Int64*는 매우 큰 범위의 수를 저장할 수 있습니다. 구체적으로 몇부터 몇까지 저장할 수 있는지를 기억하실 필요는 없습니다. 프로그램 개발하면서 *Int64* 범위를 넘어가는 수는 거의 다룰 일이 없습니다.

나아가서, 실제 개발 시에는 *Int* 외의 자료형은 거의 쓸 일이 없습니다. 정수는 *Int*만 생각하시면 됩니다.

*Int*는 64비트 플랫폼을 기준으로 *Int64*와 같은 범위를 가집니다. 요즘은 대부분의 플랫폼이 64비트 플랫폼입니다. 즉 *Int*만으로도 가장 큰수를 처리할 수 있습니다.

단, 오픈 소스등 다른 사람이 작성한 코드를 볼 때 Int8과 같은 자료형을 사용하고 있다면 이해는 할 수 있어야 겠죠. 그 정도면 됩니다.

그런데, 굳이 Int8과 같이 적은 범위밖에 처리하지 못하는 자료형은 왜 있는 것일까요? 그것은 Int8을 사용하면 메모리를 더 적게 사용하기 때문입니다.

이전에는 메모리가 적은 환경이 많았기 때문에, 메모리를 최대한 아낄 수 있는 방형으로 개발을 했습니다. 그래서, -128 ~ 127 범위를 벗어나지 않을 것이라고 예상되는 변수는 자료형을 메모리를 적게 사용하는 Int8 같은 자료형을 사용하도록 했습니다.

그런데, 현재는 메모리가 부족을 고민할 일이 거의 없습니다. 따라서, Int8과 같이 작은 사이즈의 자료형을 쓰는 일이 점점 사라지고 있습니다.

아시겠죠? 'Int'만 기억하세요. 다른 자료형들은 그런 것들이 있구나라고만 기억해 두세요.

#### 부호없는 정수형(Unsigned Integer)

부호없는 정수형은 0, 1, 2, ... 와 같은 양수만 저장이 가능한 자료형입니다. 음수를 저장할 수 없어요.

부호없는 정수형 타입의 키워드는 *UInt*입니다.

예제를 보시죠.

```swift
var number1: UInt = 3       // number1이라는 부호없는 정수 타입 변수를 선언 하고 3으로 초기화
var number2: UInt = -3      // Error 발생!!! UInt 타입 변수에는 음수를 저장할 수 없음
var number3: UInt = 3 + 3   // number3라는 부호없는 정수 타입 변수를 선언하고 6으로 초기화
var number4: UInt = 3 - 4   // Error 발생!!! UInt 타입 변수에 음수인 -1을 저장할 수 없음
```

위 예제에 4가지 수식이 있습니다. 정수형과 동일하게 선언하고 초기화를 했죠. 그런데, 위 수식들 중에서 2번째와 4번째 수식은 에러가 발생합니다.

UInt 타입의 변수에는 음수를 저장할 수 없는데 음수를 저장하려고 했기 때문이죠.

정수형과 마찬가지로 부호없는 정수형도 *UInt8*, *Uint16*, Uint32, Uint64가 있습니다.

마찬가지로 *UInt*와의 차이점은 저장할 수 있는 수의 범위입니다.

* *UInt8*: 0 ~ 255
* *UInt16*: 0 ~ 65535
* *UInt32*: 0 ~ 4294967295
* *UInt64*: 0 ~ 18446744073709551615
* *UInt*: 0 ~ 18446744073709551615

음수를 저장할 수 없다보니 부호없는 정수형 변수에 저장할 수 있는 가장 작은 수는 0입니다.

예를 들어 Uint8은 0 ~ 255까지의 정수를 저장할 수 있습니다.

정수형과 마찬가지로 UInt64는 아주 큰 양의 정수를 저장할 수 있겠네요. 굳이 몇까지 저장할 수 있는지는 기억할 필요 없어요. 웬만한 수는 UInt64 범위 내에 다 들어옵니다.

그리고, 정수형과 마찬가지로 뒤에 숫자가 없는 'UInt' 자료형은 64비트 플랫폼 기준으로 UInt64와 동일한 범위의 수를 저장할 수 있습니다.

즉, UInt만 쓰시면 된다는 겁니다. 나머지들은 그냥 저런 것들이 있구나 기억만 해 두세요. 다른 사람이 작성한 코드에서 뒤에 숫자가 붙은 자료형을 보고 당황하면 안되니까요?

그런데, 부호 없는 정수 자료형은 왜 필요할까요? 이것도 메모리와 관련이 있습니다.

Int8은 -128 ~ 127까지 저장할 수 있다고 했죠. 즉, -128부터 127까지 총 255가지의 숫자를 저장할 수 있습니다.

UInt8은 0 ~ 255까지를 저장할 수 있습니다. 즉, 0부터 255까지 총 255가지의 숫자를 저장할 수 있습니다.

그런데, Int8과 UInt8은 같은 크기의 메모리를 사용합니다. 즉, 변수에 저장하고자 하는 정수가 음수가 될 일이 없다면 UInt8로 자료형을 지정해주면 Int8로 지정할 때보다 더 큰 양수를 저장할 수 있겠죠?

여튼, 이건 상식으로만 알아두세요. 요즘은 웬만해서 메모리를 아끼기 위해 Int8, UInt8을 사용할 일은 거의 없습니다.

#### 부동 소수점형(Floating-Point Numbers)

부동 소수점형 자료형은 3.14와 같은 실수를 저장할 수 있는 자료형이며 *Float*와 *Double* 2가지 타입이 있습니다.

예제를 보시죠.

```swift
var realNUmber: Float = 3.14       // number1이라는 부호없는 정수 타입 변수를 선언 하고 3으로 초기화
var realNumber2: Double = -3.14    // Error 발생!!! UInt 타입 변수에는 음수를 저장할 수 없음
```

위 예제 중 첫번째는 realNumber라는 이름을 가진 *Float*형 변수를 선언하고 3.14라는 실수로 초기화를 하는 수식입니다.

두번째 수식은 realNumber2라른 이름을 가진 *Double*형 변수를 선언하고 -3.14라는 실수로 초기화를 하는 수식입니다.

그러면 Float와 Double의 차이점은 무었일까요?

위 두 타입은 **정밀도**에 차이점이 있습니다.

어렵죠? 쉽게 얘기해서 저장할 수 있는 소수점 아래 자리수에 차이가 있습니다.

다시, 두 수의 차이점을 확인할 수 있는 예제를 보시죠.

```swift
let floatNumber: Float = 1.1234567890123456789012345678901234567890
let doubleNumber: Double = 1.1234567890123456789012345678901234567890
let realNumber = 1.1234567890123456789012345678901234567890

print(floatNumber)
print(doubleNumber)
print(realNumber)
```

위 예제를 실행하면 어떻게 될까요? 결과를 보시죠.
![double_float](/assets/posts/float_double.png)

일단 floatNumber와 doubleNumber를 화면에 출력한 결과를 비교해보면 변수 선언 시 초기화한 값보다 더 적은 소수점 아래 자리수를 가진 수가 저장이 되어 있는 것을 볼 수 있죠.

이로 인해 우리는 *Float*와 *Double* 타입 자료형은 각 자료형이 저장할 수 있는 범위의 소수점 아래 숫자를 저장하고 저장할 수 없는 범위의 자리수는 잘라서 버린다는 것을 알 수 있습니다.

그리고, *Float*와 *Double*타입 자료형의 상수에 저장된 소수점 아래 자리수가 다르다는 것도 확인하실 수 있죠?

이는 *Float*와 *Double* 자료형이 저장할 수 있는 소수점 아래 자리수가 다르다는 것을 의미합니다.

*Double*타입의 자료형이 *Float*타입의 자료형보다 저장할 수 있는 소수점 아래 자리수가 더 많은 것이 보이시죠?

이는 *Double* 타입의 자료형이 *Float*타입의 자료형보다 더 정밀한 수를 저장할 수 있다는 의미이며 다른 말로 *Double*이 *Float*보다 **정밀도**가 높다고 할 수 있습니다.

그리고, 위 예제에서 realNumber 상수와 같이 변수/상수 선언 시 *Float*, *Double*과 같은 타입을 생략하고 실수값으로 초기화 시 *Double*과 똑같은 수가 저장된 것이 보이시죠?

따라서, 변수 선언 시 타입을 생략하고 실수값으로 초기화 시 자동으로 *Double*타입의 자료형으로 지정된다는 것을 알수 있습니다.
